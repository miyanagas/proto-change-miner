# 研究計画書：マイクロサービス契約における進化的結合の分析

## 1. 研究タイトル
**マイクロサービス契約の進化的結合：Protocol Buffers変更に伴う共変更パターンの実証的研究**
*(Evolutionary Coupling in Microservice Contracts: An Empirical Study on Co-change Patterns of Protocol Buffers)*

## 2. 研究背景と課題
マイクロサービスアーキテクチャにおいて、サービス間の通信契約（コントラクト）の管理はシステムの信頼性を左右する最重要課題の一つです。Googleによって開発されたProtocol Buffers (Protobuf) は、gRPCなどの通信基盤においてスキーマ定義のデファクトスタンダードとして広く採用されています。

`.proto` ファイル（スキーマ定義）への変更は、単なる定義の修正にとどまりません。その変更は必然的に以下の要素への波及効果を引き起こす可能性があります：

- 自動生成コード: スタブやスケルトンコードの再生成。
- ビジネスロジック: APIハンドラの実装修正。
- 品質保証: テストコード（単体テスト、契約テスト）の更新。
- 構成管理: デプロイ設定やドキュメントの更新。

しかし、実際の開発現場において「`.proto`ファイルの変更が、具体的にどのファイル群への変更を強制するのか（Logical Coupling）」についての定量的かつ包括的な知見は不足しています。本研究では、ソフトウェアリポジトリマイニング（MSR）の手法を用いてこの「共変更（Co-change）」の実態を解明し、より安全なスキーマ進化のための知見を提供します。

## 3. リサーチクエスチョン (RQ)
本研究では、以下の3つの問いに答えることを目指します。

- RQ1 (Artifact Taxonomy): `.proto`ファイルが変更される際、統計的に有意な確率で共変更されるファイルの種類（アーティファクト）は何か？（例：実装コード vs テストコード vs 設定ファイル）
- RQ2 (Modification Scale): Protobufの変更規模（行数や変更されたメッセージ数）は、共変更されるファイルの範囲や数と相関があるか？
- RQ3 (Temporal Coupling Strength): 特定のファイルパターン（例：`.proto` と `_test.go`）間の相関ルールにおける「確信度（Confidence）」と「リフト値（Lift）」はどの程度か？

## 4. 研究方法 (Methodology)
### 4.1 データ収集 (Data Collection)
- 対象リポジトリ: GitHub上の著名なOSSマイクロサービスプロジェクト（CNCF関連プロジェクト、gRPCエコシステムなど）および、協力が得られれば企業の社内リポジトリ。
    - 選定基準: 言語はGo, Java, Pythonなどを主とし、Protobufを明示的に使用しており、かつコミット数が一定（例: 1,000以上）を超えているもの。

- 抽出プロセス:
    1. リポジトリのクローン。
    2. `.proto` ファイルへの変更が含まれるコミットのみをフィルタリング。
    3. マージコミットおよび巨大なリファクタリングコミット（外れ値）の除外。

### 4.2 データ分析手法 (Data Analysis)
収集したコミットデータに対し、以下の手順で分析を行います。

1. ファイル分類と前処理:
- 変更されたファイルを拡張子およびパスに基づいて分類します（例: `*.pb.go` は生成コード、`*_test.go` はテストコード、`Dockerfile` は設定ファイル）。

2. 共変更の定義:
- 同一コミット内で変更されたファイルを「共変更された」とみなします。

3. 相関ルールマイニング (Association Rule Mining):
- AprioriアルゴリズムまたはFP-Growthアルゴリズムを使用し、`.proto`変更を前提条件（Antecedent）とした場合の共起パターンを導出します。
- 主要指標:
    - Support (支持度): その組み合わせが出現する頻度。
    - Confidence (確信度): `.proto`が変わった時に、ターゲットファイルが変わる条件付き確率。
    - Lift (リフト値): その共起が偶然以上のものであるかの指標。

## 5. 予想される結果と貢献
### 予想される結果
- 生成コード（`*.pb.x`）はほぼ100%に近い共変更率を示す（ベースライン確認）。
- テストコードの共変更率は、APIの実装コードよりも低い可能性がある（テスト追随の遅れの示唆）。
- 破壊的変更（Breaking Changes）と非破壊的変更で、共変更されるファイルの分布が異なる。

### 学術的・実務的貢献
1. インパクト分析ツールの高度化: PR作成時に「`.proto`を変更しましたが、対応するテストコードが変更されていません」といった自動警告を出すBotの開発に寄与できる。
2. テスト戦略の最適化: スキーマ変更時に実行すべきテスト範囲の特定（Regression Test Selection）の精度向上。
3. 開発プロセスの改善: スキーマ駆動開発におけるボトルネックの特定。

## 6. スケジュールフェーズ期間主なタスク
フェーズ|期間|主なタスク
---|---|---
準備|1ヶ月目|関連文献調査（MSR, Schema Evolution）、リサーチデザインの確定
データ収集|2-3ヶ月目|対象リポジトリの選定、マイニングスクリプトの実装、データセット作成
分析|4-5ヶ月目|共変更パターンの抽出、相関ルール分析、統計的検定
考察・執筆|6ヶ月目|結果の解釈、論文執筆、可視化グラフの作成

## 7. 使用ツール・技術スタック
本研究では、再現性と効率性を重視し、Pythonエコシステムを中心とした以下のスタックを提案します。

- 言語: Python 3.9+
- MSR/Git分析ライブラリ:
    - PyDriller: Gitリポジトリのトラバーサル、複雑なフィルタリングに最適。本研究の核となるツール。
    - GitPython: 低レイヤーなGit操作が必要な場合の補助。
- データ処理・分析:
    - Pandas: データフレーム操作。
    - MLxtend: 相関ルールマイニング（Apriori, Association Rules）の実装に使用。
- 可視化:
    - Matplotlib / Seaborn: 共変更マトリックス（ヒートマップ）や分布図の作成。